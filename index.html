<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>T字路口｜主線1/主線2(4車道)＋尖峰交錯放行＋行人可選斑馬線</title>
  <style>
    :root{
      --bg:#0b1220;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --good:#3cff7a;
      --bad:#ff3b3b;
      --warn:#ffd43b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial;
      background: radial-gradient(1200px 800px at 30% 20%, #18234a 0%, var(--bg) 55%, #060a14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
    }
    .wrap{
      width:min(1280px, 100%);
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 1fr 440px;
      gap:16px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      overflow:hidden;
    }
    .canvasWrap{ padding:12px; }
    canvas{
      width:100%;
      height:650px;
      display:block;
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .panel{ padding:14px; background: rgba(0,0,0,0.12); }
    h1{ font-size:15px; margin:0 0 10px 0; letter-spacing:.4px; line-height:1.3;}
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot.green{background:var(--good)}
    .dot.red{background:var(--bad)}
    .dot.yellow{background:var(--warn)}
    .divider{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin:10px 0; }
    label{ font-size: 13px; color: var(--muted); }
    input[type="number"]{
      width: 160px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
    .btns{ display:flex; gap:10px; margin-top:12px; }
    button{
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03));
      color: var(--text);
      cursor:pointer;
      font-weight: 600;
    }
    button:hover{filter:brightness(1.08)}
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin: 8px 0;
      font-size: 13px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .tiny{ font-size: 11px; color: var(--muted); line-height: 1.5; }
    .subcard{
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.16);
      margin-top: 10px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 8px;
    }
    .checkrow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 6px 0;
    }
    input[type="checkbox"]{ transform: scale(1.1); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card panel">
      <h1>Ｔ字路口：主線1（左右）＋主線2（下方 4 車道：左轉2、右轉2）＋尖峰交錯＋行人可選斑馬線</h1>

      <div class="pill">
        <span class="dot green" id="phaseDot"></span>
        <span id="phaseText">Phase：主線1 直行綠</span>
      </div>

      <div class="row">
        <label>尖峰模式（主線2 同向2線交錯）</label>
        <input type="checkbox" id="peak" checked />
      </div>

      <div class="divider"></div>

      <div class="row">
        <label>主線1 直行綠秒（M1_G）</label>
        <input type="number" id="tM1G" min="5" max="120" value="16" />
      </div>
      <div class="row">
        <label>主線1 直行黃秒（M1_Y）</label>
        <input type="number" id="tM1Y" min="2" max="10" value="3" />
      </div>

      <div class="row">
        <label>主線1 轉入主線2 綠（M1_T_G）</label>
        <input type="number" id="tM1TG" min="5" max="120" value="8" />
      </div>
      <div class="row">
        <label>主線1 轉入主線2 黃（M1_T_Y）</label>
        <input type="number" id="tM1TY" min="2" max="10" value="2" />
      </div>

      <div class="row">
        <label>主線2 左轉綠（M2_L_G）</label>
        <input type="number" id="tM2LG" min="5" max="120" value="10" />
      </div>
      <div class="row">
        <label>主線2 左轉黃（M2_L_Y）</label>
        <input type="number" id="tM2LY" min="2" max="10" value="2" />
      </div>

      <div class="row">
        <label>主線2 右轉綠（M2_R_G）</label>
        <input type="number" id="tM2RG" min="5" max="120" value="10" />
      </div>
      <div class="row">
        <label>主線2 右轉黃（M2_R_Y）</label>
        <input type="number" id="tM2RY" min="2" max="10" value="2" />
      </div>

      <div class="row">
        <label>全紅緩衝秒（AR）</label>
        <input type="number" id="tAR" min="1" max="15" value="2" />
      </div>

      <div class="row">
        <label>車流生成率（0~1）</label>
        <input type="number" id="spawn" min="0" max="1" step="0.05" value="0.60" />
      </div>

      <div class="subcard">
        <div class="tiny">
          行人相位：勾選要放行的斑馬線，並設定每條 WALK/CLEAR 秒數。<br/>
          策略：逐一放行（左→右→下），行人期間車輛全紅。
        </div>

        <div class="grid2">
          <div class="subcard" style="margin:0;">
            <div class="checkrow">
              <label>左斑馬線</label><input type="checkbox" id="pLeftOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pLeftWalk" min="3" max="60" value="7" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pLeftClr" min="2" max="20" value="3" /></div>
          </div>

          <div class="subcard" style="margin:0;">
            <div class="checkrow">
              <label>右斑馬線</label><input type="checkbox" id="pRightOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pRightWalk" min="3" max="60" value="7" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pRightClr" min="2" max="20" value="3" /></div>
          </div>

          <div class="subcard" style="margin:0; grid-column:1 / span 2;">
            <div class="checkrow">
              <label>下方斑馬線</label><input type="checkbox" id="pBottomOn" checked />
            </div>
            <div class="row"><label>WALK</label><input type="number" id="pBottomWalk" min="3" max="60" value="8" /></div>
            <div class="row"><label>CLEAR</label><input type="number" id="pBottomClr" min="2" max="20" value="3" /></div>
          </div>
        </div>
      </div>

      <div class="btns">
        <button id="toggle">暫停</button>
        <button id="reset">重置</button>
      </div>

      <div class="divider"></div>

      <div class="kv"><div>主線1 直行</div><div class="mono" id="sigM1">GREEN</div></div>
      <div class="kv"><div>主線1 轉入主線2</div><div class="mono" id="sigM1T">RED</div></div>
      <div class="kv"><div>主線2 左轉（2線）</div><div class="mono" id="sigM2L">RED</div></div>
      <div class="kv"><div>主線2 右轉（2線）</div><div class="mono" id="sigM2R">RED</div></div>
      <div class="kv"><div>尖峰放行車道（主線2）</div><div class="mono" id="laneInfo">ALL</div></div>
      <div class="kv"><div>行人</div><div class="mono" id="sigPed">STOP</div></div>
      <div class="kv"><div>本相位剩餘秒</div><div class="mono" id="count">--</div></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const $ = (id) => document.getElementById(id);

  const ui = {
    peak: $('peak'),
    tM1G: $('tM1G'), tM1Y: $('tM1Y'),
    tM1TG: $('tM1TG'), tM1TY: $('tM1TY'),
    tM2LG: $('tM2LG'), tM2LY: $('tM2LY'),
    tM2RG: $('tM2RG'), tM2RY: $('tM2RY'),
    tAR: $('tAR'),
    spawn: $('spawn'),

    pLeftOn: $('pLeftOn'), pRightOn: $('pRightOn'), pBottomOn: $('pBottomOn'),
    pLeftWalk: $('pLeftWalk'), pLeftClr: $('pLeftClr'),
    pRightWalk: $('pRightWalk'), pRightClr: $('pRightClr'),
    pBottomWalk: $('pBottomWalk'), pBottomClr: $('pBottomClr'),

    toggle: $('toggle'), reset: $('reset'),

    phaseDot: $('phaseDot'), phaseText: $('phaseText'),
    sigM1: $('sigM1'), sigM1T: $('sigM1T'),
    sigM2L: $('sigM2L'), sigM2R: $('sigM2R'),
    laneInfo: $('laneInfo'),
    sigPed: $('sigPed'), count: $('count'),
  };

  const SIG = { RED:'RED', YELLOW:'YELLOW', GREEN:'GREEN' };

  function resizeCanvasToCSS(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
    }
  }

  function geom(){
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    const road = { y: Math.round(H*0.38), h: 150, x: Math.round(W*0.52), w: 190 };
    const inter = { x0: road.x-road.w/2, x1: road.x+road.w/2, y0: road.y-road.h/2, y1: road.y+road.h/2 };

    // 主線1（左右）
    const lane = {
      m1_east_y: road.y + 20,
      m1_west_y: road.y - 20,

      // ✅ 主線2（下方）4 車道：左轉2線 + 右轉2線
      // 我用 x 位置分群：左轉兩線在左側、右轉兩線在右側
      m2_left_x:  [road.x - 42, road.x - 18],  // L1, L2
      m2_right_x: [road.x + 18, road.x + 42],  // R1, R2
    };

    return { W,H,road,inter,lane };
  }

  function clampInt(v,min,max){
    const n = Math.round(Number(v)||0);
    return Math.max(min, Math.min(max, n));
  }

  function getDur(){
    return {
      M1G: clampInt(ui.tM1G.value, 5, 120),
      M1Y: clampInt(ui.tM1Y.value, 2, 10),
      M1TG: clampInt(ui.tM1TG.value, 5, 120),
      M1TY: clampInt(ui.tM1TY.value, 2, 10),
      M2LG: clampInt(ui.tM2LG.value, 5, 120),
      M2LY: clampInt(ui.tM2LY.value, 2, 10),
      M2RG: clampInt(ui.tM2RG.value, 5, 120),
      M2RY: clampInt(ui.tM2RY.value, 2, 10),
      AR: clampInt(ui.tAR.value, 1, 15),
    };
  }

  // Ped steps
  let pedSteps = [];
  let pedIndex = 0;

  function buildPedSteps(){
    const steps = [];
    const add = (name, on, walkEl, clrEl) => {
      if (!on) return;
      const w = clampInt(walkEl.value, 3, 60);
      const c = clampInt(clrEl.value, 2, 20);
      steps.push({ key:`${name}_WALK`, dur:w });
      steps.push({ key:`${name}_CLR`, dur:c });
    };
    add('LEFT', ui.pLeftOn.checked, ui.pLeftWalk, ui.pLeftClr);
    add('RIGHT', ui.pRightOn.checked, ui.pRightWalk, ui.pRightClr);
    add('BOTTOM', ui.pBottomOn.checked, ui.pBottomWalk, ui.pBottomClr);
    if (steps.length === 0) steps.push({ key:'NONE_CLR', dur: 2 });
    return steps;
  }

  // Phases
  const PH = {
    M1_G:'M1_G', M1_Y:'M1_Y', AR1:'AR1',
    M1_T_G:'M1_T_G', M1_T_Y:'M1_T_Y', AR2:'AR2',
    M2_L_G:'M2_L_G', M2_L_Y:'M2_L_Y', AR3:'AR3',
    M2_R_G:'M2_R_G', M2_R_Y:'M2_R_Y', AR4:'AR4',
    PSEQ:'PSEQ', AR5:'AR5',
  };

  let phase = PH.M1_G;
  let remaining = 0;

  // ✅ 尖峰交錯控制：只對「當下放行的那個轉向群（左轉群或右轉群）」交錯
  let m2ActiveLaneInGroup = -1;   // -1=ALL(離峰兩線同放), 0/1 = 群內第1/2線
  let m2PhaseTotal = 0;

  function durationForPhase(ph){
    const d = getDur();
    switch(ph){
      case PH.M1_G: return d.M1G;
      case PH.M1_Y: return d.M1Y;
      case PH.M1_T_G: return d.M1TG;
      case PH.M1_T_Y: return d.M1TY;
      case PH.M2_L_G: return d.M2LG;
      case PH.M2_L_Y: return d.M2LY;
      case PH.M2_R_G: return d.M2RG;
      case PH.M2_R_Y: return d.M2RY;
      case PH.PSEQ: return (pedSteps[pedIndex]?.dur ?? d.AR);
      default: return d.AR;
    }
  }

  function nextPhase(ph){
    switch(ph){
      case PH.M1_G: return PH.M1_Y;
      case PH.M1_Y: return PH.AR1;
      case PH.AR1: return PH.M1_T_G;

      case PH.M1_T_G: return PH.M1_T_Y;
      case PH.M1_T_Y: return PH.AR2;
      case PH.AR2: return PH.M2_L_G;

      case PH.M2_L_G: return PH.M2_L_Y;
      case PH.M2_L_Y: return PH.AR3;
      case PH.AR3: return PH.M2_R_G;

      case PH.M2_R_G: return PH.M2_R_Y;
      case PH.M2_R_Y: return PH.AR4;
      case PH.AR4: return PH.PSEQ;

      case PH.PSEQ: return PH.AR5;
      default: return PH.M1_G;
    }
  }

  function enterPhase(newPhase){
    phase = newPhase;

    if (phase === PH.PSEQ){
      pedSteps = buildPedSteps();
      pedIndex = 0;
      remaining = pedSteps[pedIndex].dur;
      m2ActiveLaneInGroup = -1;
      m2PhaseTotal = 0;
      return;
    }

    remaining = durationForPhase(phase);

    if (phase === PH.M2_L_G || phase === PH.M2_R_G){
      m2PhaseTotal = remaining;
      m2ActiveLaneInGroup = ui.peak.checked ? 0 : -1;
    } else {
      m2ActiveLaneInGroup = -1;
      m2PhaseTotal = 0;
    }
  }

  function tick1s(){
    remaining -= 1;

    // ✅ 尖峰交錯：在 M2_*_G 前半放 lane0，後半放 lane1
    if (ui.peak.checked && (phase === PH.M2_L_G || phase === PH.M2_R_G) && m2PhaseTotal > 0){
      const elapsed = m2PhaseTotal - remaining;
      const half = Math.floor(m2PhaseTotal / 2);
      m2ActiveLaneInGroup = (elapsed <= half) ? 0 : 1;
    } else if (!ui.peak.checked) {
      if (phase === PH.M2_L_G || phase === PH.M2_R_G) m2ActiveLaneInGroup = -1;
    }

    if (remaining > 0) return;

    if (phase === PH.PSEQ){
      pedIndex += 1;
      if (pedIndex < pedSteps.length){
        remaining = pedSteps[pedIndex].dur;
        return;
      }
      enterPhase(PH.AR5);
      return;
    }

    const nxt = nextPhase(phase);
    if (nxt === PH.PSEQ){
      pedSteps = buildPedSteps();
      pedIndex = 0;
      enterPhase(PH.PSEQ);
      return;
    }
    enterPhase(nxt);
  }

  function signals(){
    const all = {
      m1: SIG.RED, m1t: SIG.RED, m2l: SIG.RED, m2r: SIG.RED,
      pedLeft: 'STOP', pedRight: 'STOP', pedBottom: 'STOP',
    };

    if (phase === PH.PSEQ){
      const step = pedSteps[pedIndex] || { key:'NONE_CLR' };
      const s = { ...all };
      if (step.key.startsWith('LEFT_')) s.pedLeft = step.key.endsWith('_WALK') ? 'WALK' : 'CLEAR';
      if (step.key.startsWith('RIGHT_')) s.pedRight = step.key.endsWith('_WALK') ? 'WALK' : 'CLEAR';
      if (step.key.startsWith('BOTTOM_')) s.pedBottom = step.key.endsWith('_WALK') ? 'WALK' : 'CLEAR';
      return s;
    }

    if (phase === PH.M1_G) return { ...all, m1: SIG.GREEN };
    if (phase === PH.M1_Y) return { ...all, m1: SIG.YELLOW };

    if (phase === PH.M1_T_G) return { ...all, m1t: SIG.GREEN };
    if (phase === PH.M1_T_Y) return { ...all, m1t: SIG.YELLOW };

    if (phase === PH.M2_L_G) return { ...all, m2l: SIG.GREEN };
    if (phase === PH.M2_L_Y) return { ...all, m2l: SIG.YELLOW };

    if (phase === PH.M2_R_G) return { ...all, m2r: SIG.GREEN };
    if (phase === PH.M2_R_Y) return { ...all, m2r: SIG.YELLOW };

    return all;
  }

  // Cars
  const cars = [];
  const CAR_W = 22, CAR_H = 14;
  function rnd(a,b){ return a + Math.random()*(b-a); }

  // kinds:
  // M1L: 左來主線1（直行 or 轉入主線2）
  // M1R: 右來主線1（直行 or 轉入主線2）
  // M2: 下方主線2（左轉 or 右轉），並且有 groupLane 0/1（同向兩線）
  function spawnCar(g){
    const p = Number(ui.spawn.value);
    if (Math.random() > p) return;

    const r = Math.random();
    const speed = rnd(90, 135);

    if (r < 0.40){
      const route = (Math.random() < 0.25) ? 'turnDown' : 'straight';
      cars.push({ kind:'M1L', route, x:-60, y:g.lane.m1_east_y, vx:speed, vy:0, w:CAR_W, h:CAR_H, turned:false });
    } else if (r < 0.80){
      const route = (Math.random() < 0.25) ? 'turnDown' : 'straight';
      cars.push({ kind:'M1R', route, x:g.W+60, y:g.lane.m1_west_y, vx:-speed, vy:0, w:CAR_W, h:CAR_H, turned:false });
    } else {
      const route = (Math.random() < 0.5) ? 'toLeft' : 'toRight';
      const groupLane = (Math.random() < 0.5) ? 0 : 1; // ✅ 同向兩線：0/1

      const x = (route === 'toLeft')
        ? g.lane.m2_left_x[groupLane]
        : g.lane.m2_right_x[groupLane];

      cars.push({ kind:'M2', route, groupLane, x, y:g.H+70, vx:0, vy:-speed, w:CAR_H, h:CAR_W, turned:false });
    }
  }

  function stopLine(car, g){
    const m = 22;
    if (car.kind === 'M1L') return g.inter.x0 - m;
    if (car.kind === 'M1R') return g.inter.x1 + m;
    return g.inter.y1 + m;
  }

  function pastStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x > s;
    if (car.kind === 'M1R') return car.x < s;
    return car.y < s;
  }

  function approachingStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x + car.w/2 >= s - 2;
    if (car.kind === 'M1R') return car.x - car.w/2 <= s + 2;
    return car.y - car.h/2 <= s + 2;
  }

  function allowed(car, sig, g){
    if (phase === PH.PSEQ) return false;

    // 主線1
    if (car.kind === 'M1L' || car.kind === 'M1R'){
      if (car.route === 'straight'){
        if (sig.m1 === SIG.GREEN) return true;
        if (sig.m1 === SIG.YELLOW) return pastStop(car, g);
        return false;
      } else {
        if (sig.m1t === SIG.GREEN) return true;
        if (sig.m1t === SIG.YELLOW) return pastStop(car, g);
        return false;
      }
    }

    // 主線2（下方）— 左轉群 / 右轉群 各 2 線
    if (car.kind === 'M2'){
      const need = (car.route === 'toLeft') ? sig.m2l : sig.m2r;
      if (need === SIG.RED) return false;
      if (need === SIG.YELLOW) return pastStop(car, g);

      // GREEN
      if (!ui.peak.checked) return true; // 離峰：同向兩線同放
      if (m2ActiveLaneInGroup === -1) return true;
      return car.groupLane === m2ActiveLaneInGroup; // 尖峰：同向兩線交錯
    }

    return false;
  }

  function updateCars(dt, sig, g){
    for (const car of cars){
      const needStop = approachingStop(car, g) && !pastStop(car, g) && !allowed(car, sig, g);
      if (!needStop){
        car.x += car.vx * dt;
        car.y += car.vy * dt;
      }

      if (!car.turned){
        // 主線1 轉入主線2：把車導向「中間」(不細分成4線，避免太亂)
        if ((car.kind === 'M1L' || car.kind === 'M1R') && car.route === 'turnDown'){
          const turnX = g.road.x;
          if ((car.kind==='M1L' && car.x >= turnX) || (car.kind==='M1R' && car.x <= turnX)){
            car.turned = true;
            const sp = Math.abs(car.vx);
            car.vx = 0; car.vy = sp;
            car.x = g.road.x; // 中間下行
            car.w = CAR_H; car.h = CAR_W;
          }
        }

        // 主線2 轉入主線1
        if (car.kind === 'M2'){
          if (car.y <= g.road.y + 10){
            car.turned = true;
            const sp = Math.abs(car.vy);
            car.vy = 0;
            car.w = CAR_W; car.h = CAR_H;
            if (car.route === 'toLeft'){
              car.vx = -sp;
              car.y = g.lane.m1_west_y;
            } else {
              car.vx = sp;
              car.y = g.lane.m1_east_y;
            }
          }
        }
      }
    }

    for (let i=cars.length-1; i>=0; i--){
      const c = cars[i];
      if (c.x < -240 || c.x > g.W+240 || c.y < -240 || c.y > g.H+240) cars.splice(i,1);
    }
  }

  // Drawing helpers
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function dashed(x1,y1,x2,y2){
    ctx.save();
    ctx.setLineDash([16,10]);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    ctx.restore();
  }
  function zebra(x,y,w,h,dir){
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    const stripe=6,gap=6;
    if (dir==='vertical'){
      for(let yy=y; yy<y+h; yy+=stripe+gap) ctx.fillRect(x,yy,w,stripe);
    } else {
      for(let xx=x; xx<x+w; xx+=stripe+gap) ctx.fillRect(xx,y,stripe,h);
    }
    ctx.restore();
  }

  function drawRoad(g){
    ctx.clearRect(0,0,g.W,g.H);

    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0, g.road.y-g.road.h/2, g.W, g.road.h);
    ctx.fillRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    ctx.strokeStyle='rgba(255,255,255,0.16)'; ctx.lineWidth=2;
    dashed(0, g.road.y, g.W, g.road.y);
    dashed(g.road.x, g.road.y, g.road.x, g.H);

    ctx.strokeStyle='rgba(255,255,255,0.10)'; ctx.lineWidth=3;
    ctx.strokeRect(0, g.road.y-g.road.h/2, g.W, g.road.h);
    ctx.strokeRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    zebra(g.inter.x0 - 55, g.road.y-g.road.h/2 + 8, 42, g.road.h-16, 'vertical');
    zebra(g.inter.x1 + 13, g.road.y-g.road.h/2 + 8, 42, g.road.h-16, 'vertical');
    zebra(g.road.x-g.road.w/2 + 8, g.inter.y1 + 14, g.road.w-16, 42, 'horizontal');

    // stop lines
    ctx.strokeStyle='rgba(255,255,255,0.60)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(g.inter.x0-20, g.road.y+g.road.h/2-6); ctx.lineTo(g.inter.x0-20, g.road.y+6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(g.inter.x1+20, g.road.y-g.road.h/2+6); ctx.lineTo(g.inter.x1+20, g.road.y-6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(g.road.x-g.road.w/2+6, g.inter.y1+20); ctx.lineTo(g.road.x+g.road.w/2-6, g.inter.y1+20); ctx.stroke();

    // 主線2 四車道輔助線（畫在下方）
    ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=2;
    for (const x of [...g.lane.m2_left_x, ...g.lane.m2_right_x]){
      ctx.beginPath();
      ctx.moveTo(x, g.road.y+10);
      ctx.lineTo(x, g.H);
      ctx.stroke();
    }
  }

  function lamp(onCol, on){ return on ? onCol : 'rgba(255,255,255,0.12)'; }

  function draw3Lamp(x,y,state){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.45)'; roundRect(-14,-26,28,52,8); ctx.fill();
    const lamps=[
      {cy:-14,on:state==='RED',col:'rgba(255,70,70,1)'},
      {cy:  0,on:state==='YELLOW',col:'rgba(255,210,60,1)'},
      {cy: 14,on:state==='GREEN',col:'rgba(60,255,140,1)'},
    ];
    for(const l of lamps){
      ctx.beginPath(); ctx.arc(0,l.cy,7,0,Math.PI*2);
      ctx.fillStyle=lamp(l.col,l.on); ctx.fill();
    }
    ctx.restore();
  }

  function drawTurnLamp(x,y,state,glyph){
    ctx.save(); ctx.translate(x,y);
    ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2);
    const col = state==='GREEN' ? 'rgba(60,255,140,1)' : (state==='YELLOW' ? 'rgba(255,210,60,1)' : 'rgba(255,255,255,0.12)');
    ctx.fillStyle=col; ctx.fill();
    if (state !== 'RED'){
      ctx.fillStyle='rgba(0,0,0,0.55)';
      ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(glyph, 0, 1);
    }
    ctx.restore();
  }

  function drawPedHead(x,y,state){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.42)'; roundRect(-16,-14,32,28,10); ctx.fill();
    ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    if (state==='WALK'){ ctx.fillStyle='rgba(60,255,140,0.95)'; ctx.fillText('WALK',0,0); }
    else if (state==='CLEAR'){ ctx.fillStyle='rgba(255,210,60,0.95)'; ctx.fillText('CLR',0,0); }
    else { ctx.fillStyle='rgba(255,70,70,0.95)'; ctx.fillText('STOP',0,0); }
    ctx.restore();
  }

  function drawCountdown(x,y,sec){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,0.35)'; roundRect(-36,-18,72,36,12); ctx.fill();
    ctx.fillStyle='rgba(232,238,252,0.95)';
    ctx.font='16px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(String(sec).padStart(2,'0'), 0, 1);
    ctx.restore();
  }

  function drawSignals(sig, g){
    // 主線1
    draw3Lamp(g.inter.x0-34, g.road.y+g.road.h/2-30, sig.m1);
    draw3Lamp(g.inter.x1+34, g.road.y-g.road.h/2+30, sig.m1);

    // 主線1 轉入主線2
    drawTurnLamp(g.road.x-60, g.road.y+8, sig.m1t, '↘');
    drawTurnLamp(g.road.x+60, g.road.y-8, sig.m1t, '↙');

    // 主線2 左/右
    drawTurnLamp(g.road.x-18, g.inter.y1+60, sig.m2l, '←');
    drawTurnLamp(g.road.x+18, g.inter.y1+60, sig.m2r, '→');

    // 倒數
    drawCountdown(g.road.x - 34, g.road.y - 60, remaining);

    // 行人
    drawPedHead(g.inter.x0 - 65, g.road.y - 70, sig.pedLeft);
    drawPedHead(g.inter.x1 + 65, g.road.y + 70, sig.pedRight);
    drawPedHead(g.road.x - 95, g.inter.y1 + 70, sig.pedBottom);

    // 尖峰 active lane 提示（只提示當下群內 lane）
    if (ui.peak.checked && (phase === PH.M2_L_G || phase === PH.M2_R_G)){
      const isLeft = (phase === PH.M2_L_G);
      const x = isLeft ? g.lane.m2_left_x[m2ActiveLaneInGroup] : g.lane.m2_right_x[m2ActiveLaneInGroup];
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
      const tag = isLeft ? `L${m2ActiveLaneInGroup+1}` : `R${m2ActiveLaneInGroup+1}`;
      ctx.fillText(`ACTIVE ${tag}`, x-34, g.road.y+120);
      ctx.restore();
    }
  }

  function drawCars(){
    for (const car of cars){
      ctx.save();
      ctx.translate(car.x, car.y);

      if (Math.abs(car.vx) > Math.abs(car.vy)){
        if (car.vx < 0) ctx.rotate(Math.PI);
      } else {
        if (car.vy < 0) ctx.rotate(-Math.PI/2);
        else if (car.vy > 0) ctx.rotate(Math.PI/2);
      }

      // 用不同色系區分主線2 左/右群 & lane
      if (car.kind === 'M2'){
        if (car.route === 'toLeft'){
          ctx.fillStyle = (car.groupLane === 0) ? 'rgba(120,200,255,0.95)' : 'rgba(100,240,200,0.95)';
        } else {
          ctx.fillStyle = (car.groupLane === 0) ? 'rgba(170,160,255,0.95)' : 'rgba(230,190,255,0.95)';
        }
      } else {
        ctx.fillStyle = 'rgba(120,200,255,0.95)';
      }
      ctx.fillRect(-car.w/2, -car.h/2, car.w, car.h);

      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.fillRect(-car.w/2 + 4, -car.h/2 + 3, car.w*0.4, car.h-6);

      ctx.fillStyle='rgba(255,80,80,0.8)';
      ctx.fillRect(car.w/2 - 4, -car.h/2 + 3, 3, car.h-6);

      ctx.restore();
    }
  }

  function phaseLabel(){
    if (phase === PH.PSEQ){
      const k = pedSteps[pedIndex]?.key || 'NONE';
      return [`行人序列：${k}`, 'green'];
    }
    switch(phase){
      case PH.M1_G: return ['主線1 直行綠（M1_G）','green'];
      case PH.M1_Y: return ['主線1 直行黃（M1_Y）','yellow'];
      case PH.M1_T_G: return ['主線1 轉入主線2 綠（M1_T_G）','green'];
      case PH.M1_T_Y: return ['主線1 轉入主線2 黃（M1_T_Y）','yellow'];
      case PH.M2_L_G: return ['主線2 左轉綠（M2_L_G）','green'];
      case PH.M2_L_Y: return ['主線2 左轉黃（M2_L_Y）','yellow'];
      case PH.M2_R_G: return ['主線2 右轉綠（M2_R_G）','green'];
      case PH.M2_R_Y: return ['主線2 右轉黃（M2_R_Y）','yellow'];
      default: return ['全紅緩衝（AR）','red'];
    }
  }

  function updateUI(sig){
    const [txt, color] = phaseLabel();
    ui.phaseText.textContent = 'Phase：' + txt;
    ui.phaseDot.className = 'dot ' + color;

    ui.sigM1.textContent = sig.m1;
    ui.sigM1T.textContent = sig.m1t;
    ui.sigM2L.textContent = sig.m2l;
    ui.sigM2R.textContent = sig.m2r;

    if (!ui.peak.checked) ui.laneInfo.textContent = '離峰：同向2線同放';
    else if (phase === PH.M2_L_G) ui.laneInfo.textContent = `尖峰：左轉放 L${m2ActiveLaneInGroup+1}`;
    else if (phase === PH.M2_R_G) ui.laneInfo.textContent = `尖峰：右轉放 R${m2ActiveLaneInGroup+1}`;
    else ui.laneInfo.textContent = '—';

    ui.sigPed.textContent = `L:${sig.pedLeft} R:${sig.pedRight} B:${sig.pedBottom}`;
    ui.count.textContent = remaining;
  }

  // Controls / Loop
  let running = true;
  let acc = 0;
  let last = performance.now();

  function softApply(){
    if (phase === PH.PSEQ){
      const cur = pedSteps[pedIndex]?.dur ?? remaining;
      remaining = Math.min(remaining, cur);
    } else {
      remaining = Math.min(remaining, durationForPhase(phase));
    }

    if (!ui.peak.checked) {
      if (phase === PH.M2_L_G || phase === PH.M2_R_G) m2ActiveLaneInGroup = -1;
    } else {
      if (phase === PH.M2_L_G || phase === PH.M2_R_G){
        if (m2PhaseTotal <= 0) m2PhaseTotal = remaining;
        m2ActiveLaneInGroup = 0;
      }
    }
  }

  for (const el of [
    ui.peak,
    ui.tM1G,ui.tM1Y,ui.tM1TG,ui.tM1TY,ui.tM2LG,ui.tM2LY,ui.tM2RG,ui.tM2RY,ui.tAR,
    ui.pLeftOn,ui.pRightOn,ui.pBottomOn,ui.pLeftWalk,ui.pLeftClr,ui.pRightWalk,ui.pRightClr,ui.pBottomWalk,ui.pBottomClr
  ]) el.addEventListener('change', softApply);

  ui.toggle.addEventListener('click', () => {
    running = !running;
    ui.toggle.textContent = running ? '暫停' : '繼續';
  });

  ui.reset.addEventListener('click', () => {
    cars.length = 0;
    pedSteps = buildPedSteps(); pedIndex = 0;
    m2ActiveLaneInGroup = -1; m2PhaseTotal = 0;
    enterPhase(PH.M1_G);
  });

  function step(now){
    resizeCanvasToCSS();
    const g = geom();
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    if (running){
      acc += dt;
      while (acc >= 1){ acc -= 1; tick1s(); }
      if (Math.random() < dt * 3.0) spawnCar(g);
    }

    const sig = signals();
    if (running) updateCars(dt, sig, g);

    drawRoad(g);
    drawSignals(sig, g);
    drawCars();
    updateUI(sig);

    requestAnimationFrame(step);
  }

  pedSteps = buildPedSteps();
  pedIndex = 0;
  enterPhase(PH.M1_G);
  requestAnimationFrame(step);
  window.addEventListener('resize', () => resizeCanvasToCSS());
})();
</script>
</body>
</html>
